# cloudflare-tunnel

![Version: 0.2.0](https://img.shields.io/badge/Version-0.2.0-informational?style=flat-square) ![Type: application](https://img.shields.io/badge/Type-application-informational?style=flat-square) ![AppVersion: 0.6.0](https://img.shields.io/badge/AppVersion-0.6.0-informational?style=flat-square)

Manage and use cloudflare tunnels (also known as argo tunnels) on k8s cluster

### Usage

This chart allows you to deploy cloudflared for cloudflare tunnels (also known as cloudflare argo) and manage internal tunnels ingresses.
Due to the how cloudflare tunnels work, it's impossible to manage full cycle of cert creation and configuration inside container.
You will need to install [cloudflared utility](https://github.com/cloudflare/cloudflared) to create and manage tunnels.
After you installed it, login to cloudflare:
```
cloudflare login
```
It will ask you to choose zone you want to use for tunnels
Then, create your tunnel:
```
cloudflared tunnel create k8s-tunnel-1
```
Notice unique ID of tunnel which will looks like this: 70ad5745-dbdd-427a-7c69-938a035a40c5. This is ID you will need to use for cloudflared.tunnel in helm chart variables.  Name is just for easier identification of tunnel and is not used anywhere in config.
Next, you will need to create kubernetes secret with credentials generated by cloudflared:
```
kubectl create secret generic tunnel-credentials --from-file=credentials.json=/Users/your_username/.cloudflared/<your_tunnel_id>.json -n your_k8s_namespace
```
In this case, secret will be stored with name "tunnel-credentials" which is also default in helm chart.
Next, create DNS record pointing to your tunnel. You can either do that via Cloudflare portal, pointing hostname you need to cloudflare_tunnel_id.cfargotunnel.com or using cloudflared tool to point httpbin.example.com to k8s-tunnel-1:
```
cloudflared tunnel route dns k8s-tunnel-1 httpbin.example.org
```
Next step is to configure cloudflared inside k8s. Default config won't work because it requires your tunnel id in cloudflared.tunnel variable and some ingresses. Sample value block:
```yaml
cloudflared:
  tunnel: 70ad5745-dbdd-427a-7c69-938a035a40c5
  ingress:
    - hostname: httpbin.example.org
      originRequest:
        noTLSVerify: true
      service: http://httpbin.default:443
    - hostname: hello.example.org
      service: hello_world
    - service: http_status:404
  serviceMonitor:
    enabled: true
```
This config will configure cloudflared to use tunnel with id 70ad5745-dbdd-427a-7c69-938a035a40c5 and start 3 ingresses:

1) httpbin.example.org, pointing to service httpbin in namespace "default", also disabling TLS verify in case you have self-signed certificate
2) hello.example.org, internal cloudflare service which acts as "hello world" to check that tunnel works and prints some debug info (host, headers, and etc). You will still need to create dns record pointing to that tunnel like we did with httpbin - there is no automatic DNS management in cloudflare
3) 404 which will throw 404 pages in case you have DNS records pointing to that tunnel but no ingress configured with that hostname

Additionally, it will configure serviceMonitor for prometheus-operator. In case you do not use operator, and want to use annotations, metrics are on port 2000 of pod.

For more settings of ingresses please consult [official cloudflare docs](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configuration/configuration-file/ingress)

## Values

| Key | Type | Default | Description |
|-----|------|---------|-------------|
| affinity | object | `{}` | affinity rules |
| cloudflared.ingress | list | `[{"hostname":"hello.example.com","service":"hello_world"},{"service":"http_status:404"}]` | Yaml wth ingress rules |
| cloudflared.serviceMonitor.enabled | bool | `false` |  |
| cloudflared.tunnel | string | `nil` | tunnel UUID. Tunnel name will not work. Get it with 'cloudflared tunnel list' |
| cloudflared.tunnelSecret | string | `"tunnel-credentials"` | name of secret with stored tunnel credentials |
| extraEnv | list | `[]` | additional container environment variables |
| fullnameOverride | string | `""` |  |
| image.pullPolicy | string | `"IfNotPresent"` |  |
| image.repository | string | `"cloudflare/cloudflared"` | overrides default image |
| image.tag | string | `"2022.10.3"` | Overrides the image tag whose default is the chart appVersion. |
| imagePullSecrets | list | `[]` |  |
| nameOverride | string | `""` |  |
| nodeSelector | object | `{}` | node selector rules |
| podAnnotations | object | `{}` | pod annotations |
| podDisruptionBudget | object | `{"create":false,"maxUnavailable":"","minAvailable":1}` | Pod Disruption Budget configuration |
| podDisruptionBudget.create | bool | `false` | Specifies whether a PodDisruptionBudget should be created |
| podDisruptionBudget.maxUnavailable | string | `""` | Max number of pods that can be unavailable after the eviction |
| podDisruptionBudget.minAvailable | int | `1` | Min number of pods that must still be available after the eviction |
| podSecurityContext | object | `{}` | pod security context |
| replicaCount | int | `1` | Amount of replicas. Be aware that >1 replicas requires paid cloudflare loadbalancer subscription |
| resources | object | `{}` | pod limits/requests |
| securityContext | object | `{}` | security context |
| serviceAccount.annotations | object | `{}` | Annotations to add to the service account |
| serviceAccount.create | bool | `true` | Specifies whether a service account should be created |
| serviceAccount.name | string | `""` | The name of the service account to use. If not set and create is true, a name is generated using the fullname template |
| tolerations | list | `[]` | tolerations rules |

## Upgrading

A major chart version change indicates that there is an incompatible breaking change needing manual actions.